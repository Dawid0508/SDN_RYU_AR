from ryu.base import app_manager
from ryu.controller import ofp_event
from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER
from ryu.controller.handler import set_ev_cls
from ryu.ofproto import ofproto_v1_3
from ryu.lib.packet import packet, ethernet, ether_types, ipv4, ipv6, tcp, udp
from ryu.topology.api import get_switch, get_link
from ryu.topology import event
from collections import defaultdict
import time
import hashlib
import threading

# Konfiguracja
TRESHOLD_HIGH = 0.9
TRESHOLD_LOW = 0.7
MAX_COST = 1000
DEFAULT_COST = 1
IDLE_TIMEOUT = 100
CLEANUP_INTERVAL = 60

# Struktury danych
switches = []
adjacency = defaultdict(lambda: defaultdict(lambda: {"port": None, "cost": DEFAULT_COST}))
link_load = defaultdict(lambda: {"tx_bytes": 0, "rx_bytes": 0, "timestamp": 0})
fft = {}
mac_to_dpid = {}


def minimum_distance(distance, Q):
    min_dist = float('inf')
    min_node = None
    for node in Q:
        if distance[node] < min_dist:
            min_dist = distance[node]
            min_node = node
    return min_node


def calculate_path(src, dst):
    distance = {node: float('inf') for node in switches}
    previous = {node: None for node in switches}
    distance[src] = 0
    Q = set(switches)

    while Q:
        u = minimum_distance(distance, Q)
        if u is None:
            break
        Q.remove(u)

        for v in switches:
            if adjacency[u][v]["port"] is not None:
                cost = adjacency[u][v]["cost"]
                alt = distance[u] + cost
                if alt < distance[v]:
                    distance[v] = alt
                    previous[v] = u

    path = []
    current = dst
    while current is not None:
        path.insert(0, current)
        current = previous[current]
        if current == src:
            path.insert(0, current)
            break

    if not path or path[0] != src:
        return None
    return path


def get_ports(path):
    ports = []
    for s1, s2 in zip(path[:-1], path[1:]):
        out_port = adjacency[s1][s2]["port"]
        in_port = adjacency[s2][s1]["port"]
        ports.append((s1, in_port, out_port))
    return ports


def calculate_flow_id(packet, in_port, eth_src, eth_dst):
    ip_proto = 0
    src_port = 0
    dst_port = 0
    try:
        ip_header = packet.get_protocol(ipv4.ipv4) or packet.get_protocol(ipv6.ipv6)
        if ip_header:
            ip_proto = ip_header.proto
            tcp_header = packet.get_protocol(tcp.tcp)
            udp_header = packet.get_protocol(udp.udp)
            if tcp_header:
                src_port = tcp_header.src_port
                dst_port = tcp_header.dst_port
            elif udp_header:
                src_port = udp_header.src_port
                dst_port = udp_header.dst_port
    except Exception:
        pass

    flow_tuple = (eth_src, eth_dst, ip_proto, src_port, dst_port, in_port)
    flow_id = hashlib.md5(str(flow_tuple).encode('utf-8')).hexdigest()
    return flow_id


class FAMTARController(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]

    def __init__(self, *args, **kwargs):
        super(FAMTARController, self).__init__(*args, **kwargs)
        self.datapaths = {}
        self.fft_lock = threading.Lock()
        self.monitor_thread = threading.Thread(target=self._stats_loop)
        self.cleanup_thread = threading.Thread(target=self._cleanup_fft)
        self.monitor_thread.start()
        self.cleanup_thread.start()

    def add_flow(self, datapath, match, actions, priority=1, idle_timeout=0, hard_timeout=0):
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)]
        mod = parser.OFPFlowMod(datapath=datapath, match=match, cookie=0,
                                command=ofproto.OFPFC_ADD, idle_timeout=idle_timeout,
                                hard_timeout=hard_timeout, priority=priority, instructions=inst)
        datapath.send_msg(mod)

    def install_path(self, path, flow_id, ev, src_mac, dst_mac):
        msg = ev.msg
        datapath = msg.datapath
        parser = datapath.ofproto_parser

        for sw, in_port, out_port in path:
            dp = self.datapaths[sw]
            match = parser.OFPMatch(in_port=in_port, eth_src=src_mac, eth_dst=dst_mac)
            actions = [parser.OFPActionOutput(out_port)]
            self.add_flow(dp, match, actions, idle_timeout=IDLE_TIMEOUT)

        with self.fft_lock:
            fft[flow_id] = (path[0][2], time.time())

    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        datapath = ev.msg.datapath
        self.datapaths[datapath.id] = datapath
        parser = datapath.ofproto_parser
        ofproto = datapath.ofproto
        match = parser.OFPMatch()
        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER, ofproto.OFPCML_NO_BUFFER)]
        self.add_flow(datapath, match, actions, priority=0)

    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def packet_in_handler(self, ev):
        msg = ev.msg
        datapath = msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        in_port = msg.match['in_port']
        pkt = packet.Packet(msg.data)
        eth = pkt.get_protocol(ethernet.ethernet)

        if eth.ethertype == ether_types.ETH_TYPE_LLDP or eth.dst == 'ff:ff:ff:ff:ff:ff':
            return

        dst_mac = eth.dst
        src_mac = eth.src
        dpid = datapath.id

        if src_mac not in mac_to_dpid:
            mac_to_dpid[src_mac] = dpid

        if dst_mac not in mac_to_dpid:
            actions = [parser.OFPActionOutput(ofproto.OFPP_FLOOD)]
            out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,
                                      in_port=in_port, actions=actions, data=msg.data)
            datapath.send_msg(out)
            return

        dst_dpid = mac_to_dpid[dst_mac]
        flow_id = calculate_flow_id(pkt, in_port, src_mac, dst_mac)

        with self.fft_lock:
            if flow_id in fft:
                out_port, timestamp = fft[flow_id]
                fft[flow_id] = (out_port, time.time())
                actions = [parser.OFPActionOutput(out_port)]
                out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,
                                          in_port=in_port, actions=actions, data=msg.data)
                datapath.send_msg(out)
                return

        path = calculate_path(dpid, dst_dpid)
        if path:
            ports = get_ports(path)
            self.install_path(ports, flow_id, ev, src_mac, dst_mac)
            out_port = ports[0][2]
            actions = [parser.OFPActionOutput(out_port)]
        else:
            actions = [parser.OFPActionOutput(ofproto.OFPP_FLOOD)]

        out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,
                                  in_port=in_port, actions=actions, data=msg.data)
        datapath.send_msg(out)

    @set_ev_cls(event.EventSwitchEnter)
    def switch_enter_handler(self, ev):
        switch = ev.switch
        if switch.dp.id not in switches:
            switches.append(switch.dp.id)

    @set_ev_cls(event.EventSwitchLeave)
    def switch_leave_handler(self, ev):
        switch = ev.switch
        if switch.dp.id in switches:
            switches.remove(switch.dp.id)

    @set_ev_cls(event.EventLinkAdd)
    def link_add_handler(self, ev):
        link = ev.link
        src_dpid = link.src.dpid
        dst_dpid = link.dst.dpid
        src_port = link.src.port_no
        dst_port = link.dst.port_no
        adjacency[src_dpid][dst_dpid]["port"] = src_port
        adjacency[dst_dpid][src_dpid]["port"] = dst_port
        adjacency[src_dpid][dst_dpid]["cost"] = DEFAULT_COST
        adjacency[dst_dpid][src_dpid]["cost"] = DEFAULT_COST

    @set_ev_cls(event.EventLinkDelete)
    def link_delete_handler(self, ev):
        link = ev.link
        src_dpid = link.src.dpid
        dst_dpid = link.dst.dpid
        if src_dpid in adjacency and dst_dpid in adjacency[src_dpid]:
            del adjacency[src_dpid][dst_dpid]
        if dst_dpid in adjacency and src_dpid in adjacency[dst_dpid]:
            del adjacency[dst_dpid][src_dpid]

    def _stats_loop(self):
        while True:
            for datapath in list(self.datapaths.values()):
                parser = datapath.ofproto_parser
                req = parser.OFPFlowStatsRequest(datapath)
                datapath.send_msg(req)
            time.sleep(10)

    def _cleanup_fft(self):
        while True:
            time.sleep(CLEANUP_INTERVAL)
            with self.fft_lock:
                now = time.time()
                expired = [fid for fid, (port, ts) in fft.items() if now - ts > IDLE_TIMEOUT]
                for fid in expired:
                    del fft[fid]
